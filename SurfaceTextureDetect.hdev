<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="22.05.0.0">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<c></c>
<l>dev_update_off ()</l>
<c></c>
<l>Path:='image/lcd/mura_defects_texture_'</l>
<c></c>
<l>read_image (Image1, Path + '01')</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,1]" as_ord="1">* read_image (Image, '/Users/yishuinanfeng/Desktop/projects/halconPorjects/image/lcd/mura_defects_texture_01.png')</l>
<c></c>
<l>get_image_size (Image1, Width, Height)</l>
<c></c>
<l>dev_open_window (0, 0, Width, Height, 'black', WindowHandle)</l>
<c></c>
<l>dev_set_draw ('margin')</l>
<c></c>
<l>dev_set_line_width (3)</l>
<c></c>
<l>dev_set_color ('red')</l>
<c></c>
<l>for Index := 1 to 2 by 1</l>
<l>    read_image (Image, Path + Index$'.2i')</l>
<l>*     rgb3_to_gray (Image, Image, Image, ImageGray)</l>
<c>    </c>
<l>    decompose3 (Image, ImageR, ImageG, ImageB)</l>
<c>    </c>
<l>    estimate_background_illumination (ImageB, OutputImage)</l>
<c>    </c>
<l>    sub_image (ImageB, OutputImage, ImageSub, 2, 100)</l>
<c>    </c>
<l>*     mean_image (ImageSub, ImageMean, 9, 9)</l>
<c>    *** 中值滤波过滤随机噪声点</c>
<l>    median_image (ImageSub, ImageMean, 'circle', 9, 'mirrored')</l>
<c>    *** 1. 计算梯度图像：</c>
<c>***- 首先，对输入的图像进行梯度计算，得到图像的梯度图像。梯度图像反映了图像中像素灰度值的变化情况，通常用于确定图像中的边缘和区域。</c>
<c></c>
<c>***2. 标记区域：</c>
<c>***- 根据阈值参数，将梯度图像中的像素分为不同的区域或分水岭。像素值高于阈值的像素被认为属于一个区域，而像素值低于阈值的像素被认为属于另一个区域(这里表述应该有问题，应该是)。</c>
<c></c>
<c>***3. 分水岭变换：</c>
<c>***- 在标记的区域中，通过分水岭变换的方法，将图像中的局部极小值点（局部最小值）作为种子点，从这些种子点开始向局部最大值点（局部最大值）扩展，形成分水岭。这样可以将图像分割成不同的区域，每个区域被分隔开来，形成分水岭效果。</c>
<c></c>
<c>***4. 分割结果：</c>
<c>***- 最终，根据分水岭变换的结果，将图像分割成不同的区域或分水岭，每个区域代表一个分割区域。这样可以实现对图像的分割，将图像中的不同区域或目标分隔开来。</c>
<l>    watersheds_threshold (ImageMean, Basins, 20)</l>
<c>  ***  - Basins：输入的图像，通常是灰度图像。</c>
<c>***- ImageMean：用于计算共生矩阵的像素值的平均值。</c>
<c>***- 6：指定共生矩阵的方向，这里是水平和垂直方向。</c>
<c>***- 0：指定共生矩阵的距离，这里是0，表示只考虑相邻像素。</c>
<c>***- Energy：共生矩阵特征之一，表示图像的能量。</c>
<c>***- Correlation：共生矩阵特征之一，表示图像的相关性。</c>
<c>***- Homogeneity：共生矩阵特征之一，表示图像的均匀性。</c>
<c>***- Contrast：共生矩阵特征之一，表示图像的对比度。</c>
<l>    cooc_feature_image (Basins, ImageMean, 6, 0, Energy, Correlation, Homogeneity, Contrast)</l>
<c>    </c>
<l>    Mask:= Energy[&lt;=]0.05</l>
<l>    select_mask_obj (Basins, SelectedObjects, Mask)</l>
<c>    </c>
<l>    dev_display (Image)</l>
<c>    </c>
<l>    dev_display (SelectedObjects)</l>
<c>    </c>
<l>    stop ()</l>
<l>endfor </l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="estimate_background_illumination">
<interface>
<io>
<par name="InputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OutputImage" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>get_image_size (InputImage, Width, Height)</l>
<l>rft_generic (InputImage, FFTImage, 'to_freq', 'none', 'complex', Width)</l>
<l>gen_gauss_filter (ImageGauss, 50, 50, 0, 'n', 'rft', Width, Height)</l>
<l>convol_fft (FFTImage, ImageGauss, ImageConvol)</l>
<l>rft_generic (ImageConvol, OutputImage, 'from_freq', 'none', 'byte', Width)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="estimate_background_illumination">
<parameters>
<parameter id="InputImage"/>
<parameter id="OutputImage"/>
</parameters>
</docu>
</procedure>
</hdevelop>
